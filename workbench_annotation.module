<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\workbench_annotation\Entity\WorkbenchAnnotation;
use Drupal\Core\Form\FormStateInterface;
use Drupal\workbench_annotation\Entity\WorkbenchAnnotationSeverity;

/**
 * Implements hook_page_attachments().
 */
function workbench_annotation_page_attachments(array &$page) {
  if (!\Drupal::currentUser()->hasPermission('access workbench annotations')
    || \Drupal::service('router.admin_context')->isAdminRoute()) {
    return;
  }

  $page['#attached']['library'][] = 'workbench_annotation/main';

  $options = [];
  /** @var \Drupal\workbench_annotation\Entity\WorkbenchAnnotationSeverity[] $severities */
  $severities = WorkbenchAnnotationSeverity::loadMultiple();
  $options['default'] = [
    'id' => 'default',
    'severity_level' => 'default',
    'label' => 'Default',
  ];
  foreach ($severities as $severity_id => $severity) {
    $options[$severity_id] = [
      'id' => $severity->id(),
      'severity_level' => $severity->get('severity_level'),
      'label' => $severity->label(),
    ];
  }
  $page['#attached']['drupalSettings']['workbench_annotation'] = [
    'severities' => $options,
  ];
}

/**
 * Implements hook_entity_view_alter().
 */
function workbench_annotation_entity_view_alter(&$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  $build['#cache']['contexts'][] = 'user.permissions';

  if (!_workbench_annotation_access($entity)) {
    return;
  }

  $build['#attributes']['data-workbench-annotation-entity-id'] = $entity->getEntityTypeId() . '/' . $entity->id();
}

/**
 * Access callback to determine if an Entity can be annotated.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The Entity to check.
 *
 * @return bool
 *   TRUE if the current user can access the Entity, FALSE otherwise.
 */
function _workbench_annotation_access(EntityInterface $entity) {
  /** @var \Drupal\workbench_moderation\ModerationInformation $workbench_information */
  $workbench_information = \Drupal::service('workbench_moderation.moderation_information');

  // Check if this is the latest moderated revision and if the user has access.
  return \Drupal::currentUser()->hasPermission('access workbench annotations')
  && $workbench_information->isModeratableEntity($entity)
  && $workbench_information->isLatestRevision($entity)
  && !$entity->isNew();
}

/**
 * Adds a custom validation callback for Nodes that are moderated, so that we
 * can block Workbench transitions.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function workbench_annotation_form_node_form_alter(&$form, FormStateInterface $form_state) {
  $workbench_information = \Drupal::service('workbench_moderation.moderation_information');

  if ($workbench_information->isModeratedEntityForm($form_state->getFormObject())) {
    /* @var \Drupal\Core\Entity\ContentEntityInterface $entity */
    $entity = $form_state->getFormObject()->getEntity();
    if (_workbench_annotation_access($entity)) {
      $form['#validate'][] = 'workbench_annotation_node_form_validate';
    }
  }
}

/**
 * Validation callback for moderated Node forms. Checks if there are any
 * annotations that block the current Workbench transition, and stops the form
 * submit if so.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *  The form state.
 */
function workbench_annotation_node_form_validate(&$form, FormStateInterface $form_state) {
  /** @var \Drupal\Core\Entity\ContentEntityInterface $entity */
  $entity = $form_state->getFormObject()->getEntity();
  $element = $form_state->getTriggeringElement();

  /** @var \Drupal\workbench_moderation\StateTransitionValidation $transition_validation */
  $transition_validation = \Drupal::service('workbench_moderation.state_transition_validation');
  $transitions = $transition_validation->getValidTransitions($entity, \Drupal::currentUser());

  // Determine the current transition object based on the from and to states.
  $from_state = $entity->moderation_state->entity->id();
  $to_state = $element['#moderation_state'];
  $current_transition = FALSE;
  foreach ($transitions as $transition) {
    if ($transition->getToState() == $to_state && $transition->getFromState() == $from_state) {
      $current_transition = $transition;
    }
  }

  // Something went wrong, return early before running into errors.
  if (!$current_transition) {
    return;
  }

  // Load all annotations associated with this Entity.
  $result = \Drupal::entityQuery('workbench_annotation')
    ->condition('entity_type', $entity->getEntityTypeId())
    ->condition('entity_id', $entity->id())
    ->execute();
  /** @var \Drupal\workbench_annotation\Entity\WorkbenchAnnotation[] $annotations */
  $annotations = WorkbenchAnnotation::loadMultiple($result);

  // Check if any annotation blocks the current transition.
  foreach ($annotations as $annotation) {
    $severity_id = $annotation->getSeverityId();
    /** @var \Drupal\workbench_annotation\Entity\WorkbenchAnnotationSeverity $severity */
    $severity = WorkbenchAnnotationSeverity::load($severity_id);
    if ($severity) {
      foreach ($severity->get('blocked_moderation_transitions') as $transition) {
        if ($current_transition->id() == $transition) {
          $form_state->setErrorByName('blocked_moderation_transition', t('You cannot @label until you resolve all important annotations.', ['@label' => $current_transition->label()]));
        }
      }
    }
  }

}
